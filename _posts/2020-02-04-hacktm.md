---
layout : post
title : Hacktm CTF 2020    
---   


# HackTm 2019    
  - 4 solved :     
     👉 RSA1    
     👉 RSA2    
     👉 Prision break    
     👉 [**Baby bear**](#wu1)     
  - unsolved : many :))) but read writeup so listed here   
     👉 [**Obey_the_rules**](#wu2)

<a name="wu1"></a>     

# Baby bear     
Đây là một file bị pack bởi UPX nhưng đã bị sửa :vv   😅😅😅 Nhưng magic là vẫn đọc được đầy đủ code vì nó được compile từ assembly. Vẫn có những string cùng với một số hàm cơ bản nên việc reverse mà không cần unpack là điểu khả thi.    
![](/ctf/2020/hacktm/baby_bear/hinh1.PNG)    

Hàm ```start``` :    

![](/ctf/2020/hacktm/baby_bear/hinh2.PNG)    

Hàm start bắt đầu bằng việc đọc 16 bytes từ file /dev/urandom làm giá trị khởi tạo, chuyển nó về dạng bit theo kiểu 'a' -> '10000110' rồi in hình con gấu.   Sau đó, là đến đoạn mã hóa string :    

![](/ctf/2020/hacktm/baby_bear/hinh3.PNG)    

Do đang bị pack nên trông không ra hàm nhưng ta có thể hiểu được hàm mã hóa này có hai tham số truyền vào là độ dài đoạn mã hóa đầu ra là 46 và địa chỉ lưu giữ string là ```esi = 0x600780```.   
   
Ban đầu , mình dùng unicorn để dựng lại hàm mã hóa này, cho một input đầu vào và có được output đầu ra. Việc thiết lập unicorn theo các bước không quá phức tạp : [basic setup](https://www.notion.so/Basic-Setup-179a2615e2a7472d8083423f05126bf8) và [execute binary function](https://www.notion.so/Execute-Binary-Function-08884ed07d9b44519c44963fb641b35e) . 😁😁😁Sau khi chơi với input ngẫu nhiên và xem output đầu ra là gì, mình rút ra được nhận xét là cứ 2 bytes đầu thì output đầu ra giống nhau ít nhất là 8 bits, 3 bytes thì là 11 bits, .... (～o￣3￣)～ BÙm mình định brute force từ đây. Nhưng có quá nhiều trường hợp và thời gian bruteforce có thể lên tới đơn vị tiếng mà timeout của server chỉ là 30s 🙄🙄🙄 Với trình độ mới tập chơi unicorn thì mình cũng khá là gà trong việc viết script này 😥😥😥    
Sau khi đọc lại code và cố viết lại graph cách hoạt động của chương trình thì mình cũng hiểu sơ sơ nhưng nó khá là phức tạp nên mình chỉ đọc đoạn đầu. Không ngờ có team ngồi reverse hết được :))) Chương trình họ viết lại được thì trông nó như này :)))   

![](/ctf/2020/hacktm/baby_bear/hinh4.PNG)    

Trở lại quá trình mã hóa, trong mỗi lần lặp, nó sẽ tăng esi lên từ 1 - 3 đơn vị , không thể giảm và cho ra một giá trị output, in ra màn hình bằng hàm ```sub_4000B0```. Output đầu ra có thể lấy từ chuỗi truyền vào hoặc không, do đó input mà ta tìm được có thể không giống với input ban đầu. Và nhảy tới block mã hóa tiếp theo. Có tất cả 9 block mã hóa mình đánh dấu được bằng hàm ```sub_4000B0``` - hàm set và ghi giá trị output. Mỗi block sẽ set một giá trị output xác định. 
```
return_value = {0x40010B: 1, 
                    0x400348: 1, 
                    0x400374: 0,
                    0x4003A5: 0,
                    0x4003B6: 0, 
                    0x4003CF: 0, 
                    0x400417: 1,
                    0x400463: 0, 
                    0x40047D: 1 
    } 
```    
Do việc quyết định bit đầu ra là kiểu logic mà không phải phép toán số học nên gây khó khăn cho người chơi.       

Đến đây, thì do tại mỗi bước có hai lựa chọn là '0' hoặc '1', giống hệt như một cây nhị phân. . Cứ đi theo cây nhị phân, biết vị trí hiện tại trong cây, và vị trì tiếp theo thì hoàn toàn có thể tìm được nhánh nào là nhánh cần tìm và giá trị bit nào thỏa mãn đi theo nhánh đó. Việc tự động hóa quá trình này thì hơi phức tạp hơn tí. Giờ lại nhớ lại hồi học thuật toán, sao mình không chăm chỉ hơn để giờ ngồi viết code mệt thế này 🤣🤣🤣 À nhưng sau một hồi viết thì nó cũng không quá phức tạp như mình tưởng tượng.   

Các bước sẽ như sau :    
### Bước 1 : Bắt đầu từ string rỗng, current_esi = 0x600780     
```current_esi``` là giá trị thanh ghi esi mà ở đó ta thu được k bit của chuỗi ouput cần đạt được    
### Bước 2 : Brute force từng bit của target output        
Do mỗi bước đi thanh ghi esi chỉ tăng 1-3 bit mà không giảm nên tại mỗi bước ta bruteforce 3 bit này. Dùng unicorn để xác định xem khi nào thanh ghi esi vượt quá giá trị ```current_esi```,đó là thời điểm mà chương trình sẽ set output tiếp theo. Tiếp tục trace thêm vài lệnh nữa, tại thời điểm chương trình gọi hàm ```sub_4000B0```. Đây là thời điểm chương trình set bit output tiếp theo mà chúng ta đang bruteforce. Kiểm tra bit sẽ được set dựa trên list return value trên kia, nếu đúng thì dừng :    

```python
if bytes_to_long(machine_code[1:][::-1]) + address - 0x4000B0 == 0xfffffffb :  # if call sub_4000B0
    rsi = mu.reg_read(UC_X86_REG_RSI)
    if rsi > old_rsi  :  # if we just pass old position 
        if return_value[address] == int(target_bits) :    # come to function set true target bits  
```  

Kiểm tra giá trị thanh ghi rsi, đó là độ dài chuỗi bit input ảnh hưởng tới output hiện tại, do đó ta lấy đúng số lượng bits đã đó thành input đầu vào.   
```python
# print("[***] RSI = " + hex(rsi)) 
raw_input = payload[:rsi - 0x600780]    # rsi - 0x600780 is the number byte effect to this state
old_rsi = rsi  
found = True 
```
### Bước 3 : Tiếp tục bruteforce từng bits như thế cho tới khi thu được kết quả cuối cùng 

<a name="#wu2"></a> 

# Obey The Rules   

Link writeup : https://blog.redrocket.club/2020/02/04/hacktm20-obeytherules/    
Qua bài này mình học thêm được một chút về shellcode.  
File này cho phép chúng ta thực hiện shellcode : 
```python
payload = "Y\0" + shellcode    
```   
Gặp shellcode là ngại rồi vì chưa luyện nhiều. Lại còn dính seccomp §(*￣▽￣*)§ Lần đầu nghe được.   
Thực ra seccomp cũng chỉ là những rules giới hạn các lệnh gọi system call thôi. Trong bài này rules bị ẩn đi, ta có thể check những seccomp gì dùng được bằng cách :   
```python   
shellcode = """
  xor rax, rax;
  mov al, {};
  syscall;
  ud2;   # crash program   
"""
``` 
Nếu rule được thông qua thì chương trình trả về ```illegal instruction``` còn không sẽ trả về ```segmentation fault```. Riêng system call ```0``` không check được bằng shellcode trên do ```strcpy``` không copy byte null. Syscall ```60 (exit)``` thì không trả về gì nếu thành công do chương trình tự động kết thúc. 



༼ つ ◕_◕ ༽つ To be continued   

