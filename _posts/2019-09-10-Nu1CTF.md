---
layout : post 
title : Nu1CTF 2019 Warmup Pwn 
---

Đây là bài heap mình chơi tuần trước nhưng không làm được.Tìm đọc [**writeup**](https://teamrocketist.github.io/2019/09/09/Pwn-N1CTF-2019-warmup/) vậy 😁😁😁  Qua bài này mình học được rất nhiều kiến thức mới.Do dạo này phải đi học + đi làm nên cũng ko có nhiều thời gian rảnh lắm. Mỗi hôm update tí để hoàn thiện bài này. Hope cuối tuần là xong để chiến giải tiếp.  


# Phân tích tĩnh IDA  
Chương trình rất dễ dịch ngược. Nó có ba hàm cơ bản :  

![hinh1](/img/ctf/Nu1CTF/hinh1.png)  

![](/img/ctf/Nu1CTF/hinh2.png)   

![](/img/ctf/Nu1CTF/hinh3.png)  

Nhưng cũng chính vì đơn giản nên tấn công nó cũng rất phức tạp và đòi hỏi nhiều kĩ thuật.  

# Double Free  
Chúng ta hoàn toàn có thể free một chunk 2 lần liên tiếp. Dù cho con trỏ heap trong node đã bị xóa nhưng vẫn còn con trỏ trong ```ptr```. Đây là một lỗi chúng ta có thể tận dụng.Do trên bản libc 2.27 đã có tcache, tất cả các chunk có size < 0x410 đều được đưa vào tcache bins . Tcache bin sẽ bỏ qua tất cả các security check nên không bị lỗi double free.  
Khi tiến hành add 1 node thì heap trở thành :  

![](/img/ctf/Nu1CTF/hinh4.PNG)  


Tức là ta đã có 1 fastbin. Sau khi double free thì chunk được đặt vào tcache bins.  
  - **Tcache bins** : A -> A  

![](/img/ctf/Nu1CTF/hinh5.PNG)  

Ta thấy như trên hình thì con trỏ FD trỏ vào chính A.Ta có single linked list. Con trỏ FD này lại vô tình nằm luôn trong phần Userdata của chunk cũ. Sau đó nếu ta tiến hành malloc thì hàm malloc sẽ cấp phát cho chúng ta bộ nhớ tại địa chỉ của A. Chúng ta có quyền sửa đổi FD thành bất kì địa chỉ nào chúng ta muốn. Và tcache bins sẽ trở thành :  
  - **tcache bins** : A -> target_addr  

Nhưng chúng ta chưa biết địa chỉ nào vì có PIE mà lại không có hàm nào để leak địa chỉ. Lưu ý một điểm là :  
```
ASLR không thay đổi 3 byte cuối của địa chỉ.  
```
Tức là 3 byte cuối cùng của địa chỉ heap trong con trỏ FD là không đổi. Vì vậy ta có thể chọn target là địa chỉ heap bằng cách sửa đổi 3 byte này.   

# Leak libc  
Chúng ta chỉ được quyền malloc fastbin. Nhưng với fastbin thì không thể leak được địa chỉ libc. Vì vậy chúng ta cần tới **unsorted bin**. Từ cách ghi đè địa chỉ được tìm thấy ở trên, ta sẽ ghi đè lên byte cuối địa chỉ của A thành ```A_addr-0x10``` để nó malloc về vùng nhớ overlap được phần size, pre_size. Ở đây ta tiến hành sửa byte đó từ ```0x51``` -> ```0x91```. Ta được 1 chunk unsorted bin.Nhưng đối với unsorted bin thì các cơ chế bảo vệ được check hết sức chặt chẽ. 🌝🌝🌝 Cho nên cần fake một số chunk ở sau để pass các cơ chế bảo vệ. Cụ thể là :  

```python 
add("a")      # 0  
add("b" * 0x30 + p64(0) + p64(0x51))    # 1 
add("c" * 0x30 + p64(0) + p64(0x1))     # 2 
delete(2) 
delete(1) 
delete(0) 
delete(0) 
# tcache bins[4] : 0x556a2e57e670 <- 0x556a2e57e670

# allocate to fix size 
add("\x70")       # tcache bins[3] : 0x556a2e57e670 <- 0x556a2e57e670
add("\x60")       # tcache bins[2] : 0x556a2e57e670 <- 0x556a2e57e660
add("\x60")       # tcache bins[1] : 0x556a2e57e660 
add("\x00")       # malloc to 0x556a2e57e660
```

Có thể debug để thấy rõ được điều trên.Cách để bypass [PIE](https://hacmao.pw/Pwnable/heap/debug_pie/).  
Free chunk 1,2 chỉ mang tính hình thức để việc malloc chunk phía sau thuận lợi. Cũng có thể chỉ free 1 chunk thì bớt 1 add, hoặc ko free chunk nào thì vẫn phải add 3 chunk mới thì mới vô đc cái ```0x556a2e57e660```. 😬😬😬 Rất magic nhưng cứ debug mà nhìn thôi.  
Sau khi vào được chunk như trên ta tiến hành overwrite size :  
```python 
add(p64(0) + p64(0x91)) 
``` 
Và kết quả :  

![](/img/ctf/Nu1CTF/hinh6.PNG)



